\documentclass[11pt, a4paper]{article}

% Essential packages
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{amsmath, amssymb}
\usepackage{geometry}
\usepackage{xcolor}
\usepackage{graphicx}
\usepackage{microtype}
\usepackage{authblk}
\usepackage{parskip}
\usepackage{hyperref}

% Bibliography
\usepackage[
  backend=biber,
  bibencoding=utf-8,
  style=numeric-comp,
  maxbibnames=99,
  doi=false,
  isbn=false,
  url=false
]{biblatex}

% Code blocks
\usepackage[finalizecache, cachedir=.]{minted}

% Custom code environment
\definecolor{LightGray}{gray}{0.95}
\newenvironment{code}[1]
{\VerbatimEnvironment
 \begin{minted}[
   frame=none,
   framesep=2mm,
   baselinestretch=1.2,
   bgcolor=LightGray,
   fontsize=\footnotesize,
   escapeinside=§§,
   mathescape=true,
 ]{#1}}
{\end{minted}}
% Bibliography resource

\addbibresource{literature.bib}
% Custom commands

\newcommand{\zeps}[3]{Z_{#1} \genfrac||{0pt}{0}{#2}{#3}}
\newcommand{\zepsr}[3]{Z_{#1}^{\mathrm{reg}} \displaystyle \genfrac||{0pt}{0}{#2}{#3}}
% Document information

\title{EpsteinLib User Manual}
\date{\today}

% Authors and affiliations
\author[1]{Andreas A. Buchheit\thanks{Contact: \href{buchheit@num.uni-sb.de}{\texttt{buchheit@num.uni-sb.de}}}}
\author[1,2]{Jonathan K. Busse}
\author[1]{Ruben Gutendorf}

\affil[1]{Department of Mathematics, Saarland University, 66123 Saarbrücken, Germany}
\affil[2]{Department of Mathematics, Saarland University, 66123 Saarbrücken, Germany \\
German Aerospace Center (DLR), 51147 Cologne, Germany}

\begin{document}
\maketitle

\tableofcontents



\section{Introduction}
EpsteinLib is a C library designed for the fast and efficient
computation of the Epstein zeta function for arbitrary multidimensional
lattices. In addition to the C library, we also offer a Python package,
epsteinlib, which can be easily installed via pip. For more information
on the properties of the Epstein zeta function and on the underlying
algorithm, see Ref.~\cite{buchheit2024computation}.

Originally studied by Epstein \cite{epstein1903theorieI,epstein1903theorieII}, the Epstein zeta function forms
the basis for computing general multidimensional lattice sums in
classical and quantum physics applications \cite{buchheit2023exact}. Together with its
regularization, it serves as the central ingredient in the singular
Euler-Maclaurin (SEM) expansion, which generalizes the 300-year-old
Euler summation formula to lattice sums in higher dimensions with
physically relevant power-law interactions \cite{buchheit2022efficient,buchheit2022singular}. An efficiently
computable representation of the Epstein zeta function is provided in
\cite{crandall2012unified,buchheitComputationLatticeSums2024,buchheit2024computation}. In \cite{buchheit2024computation}, we discuss in detail the analytical properties
of the Epstein zeta function and present an algorithm for its
computation, complete with error bounds.

\section{Usage}

For a \(d\)-dimensional lattice \(\Lambda=A\mathbb Z^d\), with
\(A\in \mathbb R^{d\times d}\) regular,
\(\boldsymbol x,\boldsymbol y \in \mathbb R^d\), and
\(\nu \in \mathbb C\), the Epstein zeta function is defined by the
Dirichlet series

\[
\zeps{\Lambda,\nu}{\boldsymbol x}{\boldsymbol y}
= \sum_{z \in \Lambda}{}^{'} \frac{e^{-2\pi i \boldsymbol y \cdot \boldsymbol z}}{\left| \boldsymbol x- \boldsymbol z\right|^\nu},\quad \mathrm{Re}(\nu)>d,
\]

which can be meromorphically continued to \(\nu \in \mathbb C\). Here,
the primed sum excludes the case \(\boldsymbol z = \boldsymbol x.\)

The Epstein zeta function is implemented in this library as

\begin{code}{c}
double complex epsteinZeta(
    double nu,
    unsigned int dim,
    const double *A,
    const double *x,
    const double *y);
\end{code}

In the Python package, it is implemented as

\begin{code}{python}
def epstein_zeta(
    nu: Union[float, int],
    A: NDArray[Union[np.integer[Any], np.floating[Any]]],
    x: NDArray[Union[np.integer[Any], np.floating[Any]]],
    y: NDArray[Union[np.integer[Any], np.floating[Any]]],
) -> complex
\end{code}



In the Mathematica package, it is implemented as

\begin{code}{mathematica}
EpsteinZeta[§\textbackslash{}§[Nu],A,x,y]
\end{code}

and evaluates to full precision over the whole parameter range up to ten
dimensions.

The Epstein zeta function admits singularities in the lattice $\boldsymbol x\in\Lambda$ and in the reciprocal lattice $\boldsymbol y\in\Lambda^*$.
To ensure numerical stability when evaluating the Epstein zeta function, we implement the following cutoffs:
\begin{itemize}
    \item If $(\boldsymbol x-\boldsymbol z)^2 < 10^{-64}$ for some $\boldsymbol z \in \Lambda$, we numerically set $\boldsymbol x = \boldsymbol z$.
    \item Similarly, if $(\boldsymbol y-\boldsymbol k)^2 < 10^{-64}$, for some $\boldsymbol k \in\Lambda^*$, we numerically set $\boldsymbol y = \boldsymbol k$.
\end{itemize}

When evaluating $\boldsymbol x\in\Lambda$ or $\boldsymbol y \in\Lambda^*$, users should set $\boldsymbol x= \boldsymbol 0$ or $\boldsymbol y = \boldsymbol 0$ and use the quasi-periodicity of the Epstein zeta function.


In addition, this library includes the regularized Epstein zeta
function, which is analytic around \(\boldsymbol y=0\), and is defined
via

\[
\zepsr{\Lambda,\nu}{\boldsymbol x}{\boldsymbol y}=
e^{2\pi i \boldsymbol x\cdot\boldsymbol y}
\zeps{\Lambda,\nu}{\boldsymbol x}{\boldsymbol y}
-\frac{\hat{s}(\boldsymbol y)}{V_{\Lambda}},
\]

where \(V_{\Lambda}=|\det A|\) is the volume of the elementary lattice
cell, and

\[
\hat{s}_\nu(\boldsymbol y) = \frac{\pi^{\nu/2}}{\Gamma(\nu/2)}\Gamma\big((d-\nu)/2\big)  (\pi \boldsymbol y^2)^{(\nu - d)/2},\quad \nu \not\in (d+2\mathbb N_0)
\]

is the distributional Fourier transform of
\(\vert\boldsymbol z \vert^{-\nu}\), where \(\Gamma\) denotes the gamma
function and we adopt the choice

\[
\hat s_{d+2k}(\boldsymbol y)= \frac{\pi^{k+d/2}}{\Gamma(k+d/2)}\frac{(-1)^{k+1}}{k!} ( \pi \boldsymbol y^2 )^{k} \log (\pi  \boldsymbol y^{2}),\quad k\in \mathbb N_0.
\]

In the c library, the regularized Epstein zeta function is included as

\begin{code}{c}
double complex epsteinZetaReg(
    double nu,
    unsigned int dim,
    const double *A,
    const double *x,
    const double *y);
\end{code}

in the Python package as

\begin{code}{python}
def epstein_zeta_reg(
    nu: Union[float, int],
    A: NDArray[Union[np.integer[Any], np.floating[Any]]],
    x: NDArray[Union[np.integer[Any], np.floating[Any]]],
    y: NDArray[Union[np.integer[Any], np.floating[Any]]],
) -> complex
\end{code}



and in the Mathematica package as

\begin{code}{mathematica}
EpsteinZetaReg[§\textbackslash{}§[Nu],A,x,y]
\end{code}

To ensure numerical stability when evaluating the regularized Epstein zeta function as a function of $\boldsymbol x$, we again implement the following cutoff:
\begin{itemize}
    \item If $(\boldsymbol x-\boldsymbol z)^2 < 10^{-64}$ for some $\boldsymbol z \in \Lambda$, we numerically set $\boldsymbol x = \boldsymbol z$.
\end{itemize}



\section{Installation}

Install our required dependencies: meson, ninja, pkg-config, python3
e.g.~with

\begin{code}{bash}
pacman -S meson ninja pkgconf python
\end{code}
for Archlinux and
\begin{code}{bash}
brew install meson ninja pkg-config python3
\end{code}
for MacOs.
Currently, we support native Windows builds only with GCC installed via
\href{https://www.msys2.org/}{\texttt{https://www.msys2.org/}}.
Different environments may or may not work.
However, for the full out of the box development experience we encourage
Windows users to use
\href{https://learn.microsoft.com/en-us/windows/wsl/install}{WSL2} and
follow the Linux installation instructions.

\subsection{Installing only the Python wrapper with pip}

Create and activate a virtual environment before installing the Python wrapper, if you're not already in one.

\begin{code}{bash}
cd C && python3 -m venv .venv && source .venv/bin/activate
\end{code}

EpsteinLib is then installed by:

\begin{code}{bash}
python -m pip install .
\end{code}

\subsection{Installing the C library and the Python wrapper with meson}

The following bash commands install the library with meson.

\begin{enumerate}
\item \mintinline{bash}{cd C}
\item \mintinline{bash}{meson setup build}
\item \mintinline{bash}{meson compile -C build}
%\item The library can be tested with \mintinline{bash}{meson test -C build}.
\end{enumerate}

Proceed either with system-wide or local installation.

\subsection{System-wide installation}

Meson supports a system-wide installation of the compiled library.
After that, you can use
\mintinline{c}{#include <epsteinZeta.h>} and
link the library with
\mintinline{bash}{gcc -lepsteinZeta}.
This may require superuser rights.


\begin{enumerate}
\setcounter{enumi}{5}
\item
  To install system-wide: \mintinline{bash}{meson install -C build}.
\item
  Try to compile the sample program in \mintinline{bash}{test lattice_sum.c} with
  the command
  \mintinline{bash}{gcc -o lattice_sum lattice_sum.c -lm -lepsteinZeta}.
  You may encounter the problem that the shared library cannot be found.
  In this case, you need to modify the environment variables. Please
  continue with the next step. Otherwise, you are done.
\item
  Update the environment variables to correctly locate the shared
  library at runtime. You can find \mintinline{bash}{/path/to/library} in the
  output given by \mintinline{bash}{meson install}.
\end{enumerate}

In Linux, the environment variable is exported by

\begin{code}{bash}
export $LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/path/to/library
\end{code}
and in MacOs by
\begin{code}{bash}
export $DYLD_LIBRARY_PATH=$DYLD_LIBRARY_PATH:/path/to/library
\end{code}

\subsection{Local installation}

\begin{enumerate}
\setcounter{enumi}{5}
\item
  Copy the header \mintinline{bash}{include/epsteinZeta.h} and move the compiled
  library \\ \mintinline{bash}{build/src/libepsteinZeta.so} to places of your choice. This can be done by
\end{enumerate}

\begin{code}{bash}
cp include/epsteinZeta.h /your/path/to/include
mv build/src/libepsteinZeta.so /your/path/to/library
\end{code}

\begin{enumerate}
\setcounter{enumi}{6}
\item
  To test your library, try to compile \mintinline{bash}{test lattice_sum.c} with
  the following command:
\end{enumerate}

\begin{code}{bash}
gcc -o lattice_sum lattice_sum.c -lm -L/your/path/to/library -lepsteinZeta \
    -I/your/path/to/include
\end{code}

\section{Documentation}

You can find our API documentation at  \href{https://epsteinlib.github.io/epsteinlib/}{\texttt{https://epsteinlib.github.io/epsteinlib/}}.

\section{Usage}

Minimal working examples for calculating the Madelung constant for NaCl in \(3\)
dimensions,
(see    \cite{burrowsMadelungConstantDimensions2022} for a reference value).

\subsection{C example}

In C, the Madelung constant is calculated as follows:

\begin{code}{c}
// If the library is installed, compile with
// `gcc -o lattice_sum lattice_sum.c -lm -lepsteinZeta
// If the library is not installed, compile with
// `gcc -o lattice_sum lattice_sum.c -lm -L/path/to/library -lepsteinZeta \
//      -I/path/to/include`

#include <complex.h>
#include <math.h>
#include <stdio.h>
#include "epsteinZeta.h"


int main() {

    // Madelung constant found in literature
    double madelungRef = -1.7475645946331821906362120355443974;
    unsigned int dim = 3;
    double m[] = {1, 0, 0, 0, 1,
                  0, 0, 0, 1};    // identity matrix for whole numbers
    double x[] = {0, 0, 0};       // no shift
    double y[] = {0.5, 0.5, 0.5}; // alternating sum
    double nu = 1.0;
    double madelung = creal(epsteinZeta(nu, dim, m, x, y));
    printf("Madelung sum in 3 dimensions:\t %.16lf\n", creal(madelung));
    printf("Reference value:\t\t %.16lf\n", madelungRef);
    printf("Relative error:\t\t\t +%.2e\n",
           fabs(madelungRef - madelung) / fabs(madelungRef));

    return fabs(madelung - madelungRef) > pow(10, -14);
}

\end{code}

\subsection{Python example}

We perform the calculation of the Madelung constant using the Python wrapper as follows.

\begin{code}{python}
import numpy as np
from epsteinlib import epstein_zeta

madelung_ref = -1.7475645946331821906362120355443974
dim = 3
a = np.identity(dim)            # identity matrix for whole numbers
x = np.zeros(dim)               # no shift
y = np.full(dim, 0.5)           # alternating sum
nu = 1.0
madelung = np.real(epstein_zeta(nu, a, x, y))
print(f"Madelung sum in 3 dimensions:\t {madelung:.16f}")
print(f"Reference value:\t\t {madelung_ref:.16f}")
print(f"Relative error:\t\t\t +{abs(madelung_ref - madelung) / abs(madelung_ref):.2e}")
\end{code}

In the \mintinline{bash}{Python/Examples/} folder, you can find two more Python
examples:

\begin{enumerate}
\item
  \texttt{dispersion\_relation\_3d.py}: This script demonstrates how to
  use EpsteinLib to calculate quantum dispersion relations in 3D.
\item
  \texttt{sem\_gaussian\_1d.py}: This script showcases the Singular
  Euler-Maclaurin (SEM) expansion for a Gaussian function in 1D. It has
  an optional argument \texttt{-\/-nu} that can be used to set the value
  of nu. For example, you can run it with
  \texttt{python\ sem\_gaussian\_1d.py\ -\/-nu\ 1}. If no value is
  provided, it defaults to $\texttt{nu} = 1.5$.
\end{enumerate}

These examples, along with the \texttt{lattice\_sum.py} script, provide
a comprehensive overview of how to use EpsteinLib in various scenarios.

\subsection{Mathematica example}

\begin{code}{mathematica}
<<"EpsteinZeta.wl"

madelungRef = -1.7475645946331821906362120355443974;

dim = 3;
A = IdentityMatrix[dim];
x = ConstantArray[0, dim];
y = ConstantArray[0.5, dim];
§\textbackslash{}§[Nu] = 1.0;

madelung = Re[EpsteinZeta[§\textbackslash{}§[Nu], A, x, y]];

Print["Madelung sum in 3 dimensions: ", NumberForm[madelung, 16]]
Print["Reference value:              ", NumberForm[madelungRef, 16]]
Print["Relative error:               ",
    ScientificForm[Abs[madelungRef - madelung]/Abs[madelungRef], 2]]
\end{code}

Executing this code snipped in the same folder as
\texttt{EpsteinZeta.wl} and setting \\
\mintinline{mathematica}{SetDirectory[NotebookDirectory[]]} is the easiest way to
help mathematica find the package.

\section{Reproducing Results}

The numerical results presented in our paper can be reproduced as follows.
To regenerate all figures, evaluate \texttt{Mathematica/ReplicateResults.wls}. On a standard 12-core laptop, the evaluation completes in under 2 minutes.
The benchmark data can be regenerated using the following steps:
\begin{enumerate}
    \item Navigate to the C directory: \mintinline{bash}{cd C}
    \item Build the project: \mintinline{bash}{meson setup build && meson compile -C build}
    \item Execute the benchmark programs:
\end{enumerate}

\begin{code}{bash}
# Regenerates benchmark values in `benchmark/csv` for epsteinZeta and epsteinZetaReg
./build/benchmark/epsteinlib_benchmark_epstein

# Regenerates benchmark values in `benchmark/csv` for the upper gamma function
./build/benchmark/epsteinlib_benchmark_gamma
\end{code}


The benchmark results are automatically saved as CSV files in \texttt{C/benchmark/csv}.

\section{Development environment}

We provide a nix devshell to have a reproducible development environment
with the same dependencies across different operating systems. Once you
have installed and configured nix, starting developing is as easy as
running \mintinline{bash}{nix develop}.

\subsection{Nix installation instructions}

\begin{enumerate}
\item
  Install \href{https://nixos.org/download/}{nix}; follow the
  \href{https://wiki.archlinux.org/title/Nix}{wiki}
\item
  Configure nix by executing
\end{enumerate}

\begin{code}{bash}
sudo tee -a /etc/nix/nix.conf <<CFG
max-jobs = auto
#max-jobs = 1
experimental-features = nix-command flakes auto-allocate-uids
auto-allocate-uids = true
auto-optimise-store = true
CFG
\end{code}

\begin{enumerate}
\setcounter{enumi}{2}
\item
  \mintinline{bash}{systemctl enable --now nix-daemon.socket}
\item
  \mintinline{bash}{usermod -a -G nix-users <your username>}
\item
  Reboot
\item
  \mintinline{bash}{cd <path/to/folder>/C}
\item
  \mintinline{bash}{bash init.sh}
\item
  \mintinline{bash}{nix develop} or
  \mintinline{bash}{nix run -- <your args>}
\end{enumerate}

\subsection{Nix-Portable based installation instructions}
We offer a Nix-portable solution, which is especially helpful if you do not have root rights.

\begin{enumerate}
\item
  Install \href{https://github.com/DavHau/nix-portable}{nix-portable}:
\end{enumerate}

\begin{code}{bash}
mkdir -p ~/.local/bin
cd ~/.local/bin

curl -L https://github.com/DavHau/nix-portable/releases/latest/download/nix-portable\
    -$(uname -m) > ./nix-portable
chmod +x ./nix-portable
cat > ./nix <<NIX
#!/usr/bin/env bash
CURDIR=\$(dirname "\$(readlink -f "\$0")")
NP_RUNTIME=bwrap "\$CURDIR/nix-portable" nix \$@
NIX
chmod +x ./nix

export PATH=~/.local/bin:"$PATH"
cd ~
nix run 'nixpkgs#hello'
\end{code}

\begin{enumerate}
\setcounter{enumi}{1}
\item
  Configure \texttt{nix.conf} by executing
\end{enumerate}

\begin{code}{bash}
tee -a ~/.nix-portable/conf/nix.conf <<CFG
max-jobs = auto
#max-jobs = 1
auto-optimise-store = true
CFG
\end{code}



\begin{enumerate}
\setcounter{enumi}{2}
\item
  Add \texttt{.local/bin} permanently to your PATH
\end{enumerate}

\begin{code}{bash}
echo 'PATH=$HOME/.local/bin:"$PATH"' >> ~/.env
echo 'export $(envsubst < .env)' | tee -a .bashrc >> .zshrc
\end{code}

\begin{enumerate}
\setcounter{enumi}{3}
\item
  \texttt{cd\ \textless{}path/to/folder\textgreater{}/C}
\item
  \mintinline{bash}{bash init.sh}
\item
  \mintinline{bash}{nix develop} or
  \mintinline{bash}{nix run -- <your args>}
\end{enumerate}

\section{Contributing}

Pull requests are welcome. For major changes, please open an issue first
to discuss what you would like to change.



\printbibliography

\end{document}
